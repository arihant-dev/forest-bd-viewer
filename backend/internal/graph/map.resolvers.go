package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"encoding/json"
	"fmt"
	"forest-bd-viewer/internal/auth"
	"forest-bd-viewer/internal/graph/model"
)

// SaveMapState is the resolver for the saveMapState field.
func (r *mutationResolver) SaveMapState(ctx context.Context, lng float64, lat float64, zoom float64) (bool, error) {
	claims := auth.GetUser(ctx)
	if claims == nil {
		return false, fmt.Errorf("authentication required")
	}

	mapJSON := fmt.Sprintf(`{"lng":%f,"lat":%f,"zoom":%f}`, lng, lat, zoom)
	_, err := r.DB.Exec(ctx,
		`UPDATE users SET preferences = jsonb_set(preferences, '{map}', $1::jsonb) WHERE id = $2`,
		mapJSON, claims.UserID,
	)
	if err != nil {
		return false, fmt.Errorf("failed to save map state: %w", err)
	}
	return true, nil
}

// MyMapState is the resolver for the myMapState field.
func (r *queryResolver) MyMapState(ctx context.Context) (*model.MapState, error) {
	claims := auth.GetUser(ctx)
	if claims == nil {
		return nil, nil
	}

	var prefsRaw json.RawMessage
	err := r.DB.QueryRow(ctx,
		`SELECT preferences FROM users WHERE id = $1`,
		claims.UserID,
	).Scan(&prefsRaw)
	if err != nil {
		return nil, nil
	}

	var prefs map[string]json.RawMessage
	if err := json.Unmarshal(prefsRaw, &prefs); err != nil {
		return nil, nil
	}

	mapRaw, ok := prefs["map"]
	if !ok {
		return nil, nil
	}

	var ms model.MapState
	if err := json.Unmarshal(mapRaw, &ms); err != nil {
		return nil, nil
	}
	return &ms, nil
}
