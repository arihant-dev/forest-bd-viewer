package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"fmt"
	"net/http"
	"time"

	"forest-bd-viewer/internal/auth"
	"forest-bd-viewer/internal/graph/generated"
	"forest-bd-viewer/internal/graph/model"
)

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, email string, password string, name string) (*model.AuthPayload, error) {
	hash, err := r.AuthSvc.HashPassword(password)
	if err != nil {
		return nil, fmt.Errorf("failed to hash password")
	}

	var user model.User
	var createdAt time.Time
	err = r.DB.QueryRow(ctx,
		`INSERT INTO users (email, password_hash, name) VALUES ($1, $2, $3) RETURNING id, email, name, created_at`,
		email, hash, name,
	).Scan(&user.ID, &user.Email, &user.Name, &createdAt)
	if err != nil {
		return nil, fmt.Errorf("registration failed: email may already be in use")
	}
	user.CreatedAt = createdAt.Format(time.RFC3339)

	token, err := r.AuthSvc.GenerateToken(user.ID, user.Email)
	if err != nil {
		return nil, fmt.Errorf("failed to generate token")
	}

	if ec := GetEchoContext(ctx); ec != nil {
		ec.SetCookie(&http.Cookie{
			Name:     "auth_token",
			Value:    token,
			HttpOnly: true,
			SameSite: http.SameSiteLaxMode,
			Path:     "/",
			MaxAge:   r.AuthSvc.ExpirySeconds(),
		})
	}

	return &model.AuthPayload{User: &user}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, email string, password string) (*model.AuthPayload, error) {
	var user model.User
	var passwordHash string
	var createdAt time.Time

	err := r.DB.QueryRow(ctx,
		`SELECT id, email, password_hash, name, created_at FROM users WHERE email = $1`,
		email,
	).Scan(&user.ID, &user.Email, &passwordHash, &user.Name, &createdAt)
	if err != nil {
		return nil, fmt.Errorf("invalid email or password")
	}
	user.CreatedAt = createdAt.Format(time.RFC3339)

	if !r.AuthSvc.CheckPassword(password, passwordHash) {
		return nil, fmt.Errorf("invalid email or password")
	}

	token, err := r.AuthSvc.GenerateToken(user.ID, user.Email)
	if err != nil {
		return nil, fmt.Errorf("failed to generate token")
	}

	if ec := GetEchoContext(ctx); ec != nil {
		ec.SetCookie(&http.Cookie{
			Name:     "auth_token",
			Value:    token,
			HttpOnly: true,
			SameSite: http.SameSiteLaxMode,
			Path:     "/",
			MaxAge:   r.AuthSvc.ExpirySeconds(),
		})
	}

	return &model.AuthPayload{User: &user}, nil
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context) (bool, error) {
	if ec := GetEchoContext(ctx); ec != nil {
		ec.SetCookie(&http.Cookie{
			Name:     "auth_token",
			Value:    "",
			HttpOnly: true,
			SameSite: http.SameSiteLaxMode,
			Path:     "/",
			MaxAge:   -1,
		})
	}
	return true, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	claims := auth.GetUser(ctx)
	if claims == nil {
		return nil, nil
	}

	var user model.User
	var createdAt time.Time
	err := r.DB.QueryRow(ctx,
		`SELECT id, email, name, created_at FROM users WHERE id = $1`,
		claims.UserID,
	).Scan(&user.ID, &user.Email, &user.Name, &createdAt)
	if err != nil {
		return nil, nil
	}
	user.CreatedAt = createdAt.Format(time.RFC3339)

	return &user, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
