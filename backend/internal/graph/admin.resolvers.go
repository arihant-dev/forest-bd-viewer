package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"fmt"
	"forest-bd-viewer/internal/graph/model"
)

// Regions is the resolver for the regions field.
func (r *queryResolver) Regions(ctx context.Context) ([]*model.Region, error) {
	rows, err := r.DB.Query(ctx, `SELECT id::text, code, nom FROM regions ORDER BY nom`)
	if err != nil {
		return nil, fmt.Errorf("failed to query regions: %w", err)
	}
	defer rows.Close()

	var out []*model.Region
	for rows.Next() {
		var reg model.Region
		if err := rows.Scan(&reg.ID, &reg.Code, &reg.Nom); err != nil {
			return nil, fmt.Errorf("failed to scan region: %w", err)
		}
		out = append(out, &reg)
	}
	return out, rows.Err()
}

// Departements is the resolver for the departements field.
func (r *queryResolver) Departements(ctx context.Context, regionCode *string) ([]*model.Departement, error) {
	q := `SELECT id::text, code, nom, region_code FROM departements`
	var args []any
	if regionCode != nil {
		q += ` WHERE region_code = $1`
		args = append(args, *regionCode)
	}
	q += ` ORDER BY nom`

	rows, err := r.DB.Query(ctx, q, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to query departements: %w", err)
	}
	defer rows.Close()

	var out []*model.Departement
	for rows.Next() {
		var d model.Departement
		if err := rows.Scan(&d.ID, &d.Code, &d.Nom, &d.RegionCode); err != nil {
			return nil, fmt.Errorf("failed to scan departement: %w", err)
		}
		out = append(out, &d)
	}
	return out, rows.Err()
}

// Communes is the resolver for the communes field.
func (r *queryResolver) Communes(ctx context.Context, departementCode *string) ([]*model.Commune, error) {
	q := `SELECT id::text, code, nom, departement_code FROM communes`
	var args []any
	if departementCode != nil {
		q += ` WHERE departement_code = $1`
		args = append(args, *departementCode)
	}
	q += ` ORDER BY nom`

	rows, err := r.DB.Query(ctx, q, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to query communes: %w", err)
	}
	defer rows.Close()

	var out []*model.Commune
	for rows.Next() {
		var c model.Commune
		if err := rows.Scan(&c.ID, &c.Code, &c.Nom, &c.DepartementCode); err != nil {
			return nil, fmt.Errorf("failed to scan commune: %w", err)
		}
		out = append(out, &c)
	}
	return out, rows.Err()
}
